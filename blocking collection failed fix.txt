using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using NotificationListener.Models;
using Polly.Retry;
using Polly;
using RabbitMQ.Client;
using RabbitMQ.Client.Exceptions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Options;
using System.Collections.Concurrent;
using System.Threading.Channels;
using System.Threading;

namespace NotificationListener.Core.FinalSenderPublisher;

public class FinalSenderPublisher : IProducer
{
    private readonly Config _rabbitMqConfiguration;
    private readonly ConnectionFactory _factory;
    private readonly ILogger<FinalSenderPublisher> _logger;
    private static volatile IConnection _connection;
    private static BlockingCollection<IModel> _channelsCollection;
    private static readonly object _channelsLock = new object();

    private readonly int RECONNECT_INTERVAL = 3;

    private readonly int RECONNECT_TRY_COUNT = 3;

    private const int CHANNELS_COLLECTION_BOUNDED_CAPACITY = 20;

    private const int CHANNEL_ADD_TAKE_TRY_COUNT = 3;

    private static int FailedChannelAddition = 0;
    public FinalSenderPublisher(
        IOptions<Config> options,
        ILogger<FinalSenderPublisher> logger
        )
    {
        _rabbitMqConfiguration = options.Value;
        _factory = new ConnectionFactory
        {
            AutomaticRecoveryEnabled = true,
            TopologyRecoveryEnabled = true,
            UserName = _rabbitMqConfiguration.Connection.UserName,
            Password = _rabbitMqConfiguration.Connection.Password,
            VirtualHost = _rabbitMqConfiguration.Connection.VirtualHost,
            NetworkRecoveryInterval = TimeSpan.FromSeconds(5.0)
        };
        _logger = logger;
    }

    public IConnection CreateConnection()
    {
        if (_connection == null || !_connection!.IsOpen)
        {
            _logger.LogInformation("_connection is null or notopen");
            _connection = _factory.TryConnection(_rabbitMqConfiguration.Connection.Hosts, _rabbitMqConfiguration.Connection.UserFriendlyName, RECONNECT_INTERVAL, (uint)RECONNECT_TRY_COUNT);
            _logger.LogInformation("_connection opened");
        }
        return _connection;
    }

    private void CreateChannelsCollection()
    {
        _channelsCollection = new BlockingCollection<IModel>(CHANNELS_COLLECTION_BOUNDED_CAPACITY);
        _logger.LogInformation("creating blocking collection for channels in FinalSenderPublisher.CreateChannelsCollection");
        int channelCount = 0;
        int retryCount = CHANNEL_ADD_TAKE_TRY_COUNT;
        for (; channelCount < CHANNELS_COLLECTION_BOUNDED_CAPACITY && retryCount > 0; channelCount++)
        {
            try
            {
                AddChannelToCollection();
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "could not create channel {channelIndex}", channelCount);
                channelCount--;
                retryCount--;
            }
        }
        if (channelCount == CHANNELS_COLLECTION_BOUNDED_CAPACITY)
        {
            _logger.LogInformation("blocking collection for channels created successfully in FinalSenderPublisher.CreateChannelsCollection");
        }
        else
        {
            _logger.LogWarning("blocking collection created with {channelCount} channels in FinalSenderPublisher.CreateChannelsCollection", channelCount);
        }
    }

    private IModel GetChannel(int retryCount = 0)
    {
        if (_channelsCollection == null)
        {
            lock (_channelsLock)
            {
                if (_channelsCollection == null)
                {
                    CreateChannelsCollection();
                }
            }
        }

        if (FailedChannelAddition > 0)
        {
            lock (_channelsLock)
            {
                while (FailedChannelAddition > 0)
                {
                    Interlocked.Decrement(ref FailedChannelAddition);
                    AddChannelToCollection();
                }
            }
        }

        try
        {
            if (_channelsCollection.TryTake(out var channelToReturn, millisecondsTimeout: -1) && channelToReturn.IsOpen)
            {
                return channelToReturn;
            }
            else
            {
                throw new Exception("BlockingCollection.TryTake returned closed channel");
            }
        }
        catch (Exception ex)
        {
            if (retryCount < CHANNEL_ADD_TAKE_TRY_COUNT)
            {
                _logger.LogWarning(ex, "could not take channel from collection in FinalSenderPublisher.GetChannel, remaining retries {retryCount}", CHANNEL_ADD_TAKE_TRY_COUNT - retryCount);
                return GetChannel(retryCount + 1);
            }
            else
            {
                _logger.LogError(ex, "could not take channel from collection in FinalSenderPublisher.GetChannel after {retryCount} tries", retryCount);
                throw;
            }
        }
    }

    private void AddChannelToCollection(IModel channel = null, int retryCount = 0)
    {
        try
        {
            IModel channelToAdd = channel?.IsClosed == false ? channel : CreateConnection().CreateModel();

            if (channelToAdd?.IsClosed == false)
            {
                _channelsCollection.Add(channelToAdd);
            }
            else
            {
                throw new Exception("IConnection.CreateModel returned closed channel");
            }
        }
        catch (Exception ex)
        {
            if (retryCount < CHANNEL_ADD_TAKE_TRY_COUNT)
            {
                _logger.LogWarning(ex, "could not add channel to collection, remaining retries {retryCount}", CHANNEL_ADD_TAKE_TRY_COUNT - retryCount);
                AddChannelToCollection(retryCount: retryCount + 1);
            }
            else
            {
                _logger.LogError(ex, "could not add channel to collection after {retryCount} tries", retryCount);
                Interlocked.Increment(ref FailedChannelAddition);
                throw;
            }
        }
    }

    public async Task PushAsync<T>(string exchange, string routingKey, T obj, int? priority = null, int retriesForConsuming = 3)
    {
        IModel channel = null;
        try
        {
            channel = GetChannel();
            await SendAsync(channel, obj, exchange, routingKey, channel.WithRetry(retriesForConsuming).WithPriority(priority));
        }
        finally
        {
            AddChannelToCollection(channel);
        }
    }
    private async Task SendAsync<T>(IModel channel, T obj, string exchange, string routingKey, IBasicProperties properties)
    {
        IModel channel2 = channel;
        string exchange2 = exchange;
        string routingKey2 = routingKey;
        IBasicProperties properties2 = properties;
        T obj2 = obj;
        await Task.Run(delegate
        {
            channel2.BasicPublish(exchange2, routingKey2, properties2, obj2.AsByteArray());
        });
    }
}
public static class Ext
{
    public static IBasicProperties WithPriority(this IBasicProperties properties, int? priority = null)
    {
        if (!priority.HasValue)
        {
            return properties;
        }

        properties.Persistent = true;
        properties.Priority = Convert.ToByte(priority.Value);
        return properties;
    }
    public static void WithRetryCount(this IBasicProperties properties, int retryCount)
    {
        if (properties.Headers == null)
        {
            properties.Headers = new Dictionary<string, object>();
        }

        properties.Headers["Retries"] = retryCount;
    }
    public static byte[] AsByteArray<T>(this T obj)
    {
        string s = JsonConvert.SerializeObject(obj);
        byte[] bytes = Encoding.UTF8.GetBytes(s);
        return bytes;
    }

    public static IBasicProperties WithRetry(this IModel channel, int retryCount)
    {
        IBasicProperties basicProperties = channel.CreateBasicProperties();
        basicProperties.WithRetryCount(retryCount);
        return basicProperties;
    }
    private static IConnection CreateConnection(ConnectionFactory _factory, string[] hosts, string connectionName)
    {
        if (hosts == null)
        {
            return _factory.CreateConnection(connectionName);
        }

        return _factory.CreateConnection(hosts, connectionName);
    }
    public static IConnection TryConnection(this ConnectionFactory _factory, string[] hosts, string connectionName, int RECONNECT_INTERVAL_SECONDS, uint MAX_RECONNECT_COUNT, ILogger _logger = null)
    {
        ILogger _logger2 = _logger;
        ConnectionFactory _factory2 = _factory;
        string[] hosts2 = hosts;
        RetryPolicy retryPolicy = Policy.Handle<BrokerUnreachableException>().Or<SocketException>().WaitAndRetry((int)MAX_RECONNECT_COUNT, (int retryAttempt) => TimeSpan.FromSeconds(RECONNECT_INTERVAL_SECONDS), delegate (Exception ex, TimeSpan time)
        {
            _logger2?.LogWarning(ex, "Could not open connection after {Timeout}s ({ExceptionMessage})", $"{time.TotalSeconds:n1}", ex.Message);
        });
        var connection = retryPolicy.Execute(() => CreateConnection(_factory2, hosts2, connectionName));
        return connection ?? throw new Exception("Error while connectiong to rabbitmq");
    }
}
